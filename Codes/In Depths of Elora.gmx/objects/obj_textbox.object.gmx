<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///READ FOR INFO

/*----------------------------------------------------//
//    Dynamic Textbox Engine V6                       //
//    by Caleb Padron (nacho_chicken)                 //
//                                                    //
//                             V6.0, August 14, 2014  //
//             Do not use without proper permissions  //
//----------------------------------------------------*/

/*||||||||||||||||||||||||||||||||||||||||||||||
-- Important note:
--
--    I don't comment every single line.
--    That's stupid and pointless.
--    I comment blocks of code at a time.
--    
--    It doesn't really matter, since you won't
--    need to change any of the inner workings
--    anyway.
--
--||||||||||||||||||||||||||||||||||||||||||||*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CUSTOMIZE TEXTBOX

//You can change text file extensions to something else
//that looks scarier, like ".dat"
TEXT_FILE_EXTENSION=".txt"; //Make this a macro if you want

draw_set_font(global.fnt_textbox); //for some calculations to work correctly

//Caps on vars; higher to raise caps and lower to save RAM
textbox_maxlines=   4;
textbox_maxcolors=  4;
textbox_maxcutins=  6;
textbox_maxoptions= 6;

textbox_fade_perstep=           .1; //how much the textbox fades per step
textbox_overall_alpha_max=      .7;
textbox_overall_alpha=          0; //for the textbox surface

//Textbox
textbox_x=                      0;
textbox_y=                      view_hport-64;
textbox_sprite=                 spr_textbox;
textbox_alpha=                  1;

//Text
textbox_text_x=                 textbox_x+8;
textbox_text_y=                 textbox_y+7;
textbox_text_color=             $000000; //black
textbox_text_alpha=             1;
textbox_font_height=            string_height("#"); //so we don't have to run string_height every time we need to use it

//Textbox arrow
textbox_arrow_x=                (textbox_x+320)-16;
textbox_arrow_y=                textbox_y+50;
textbox_arrow_sprite=           spr_textbox_arrow;
textbox_arrow_color=            $000000; //black
textbox_arrow_alpha=            1;
textbox_arrow_anim=             1; //1 for animated arrows
textbox_arrow_anim_speed=       .1;
textbox_arrow_anim_subimgs=     4;

//Name box
textbox_name_x=                 0;
textbox_name_y=                 view_hport-80;
textbox_name_sprite=            spr_textbox_namebox;
textbox_name_alpha=             1;
textbox_name_anim=              0; //1 for animated name boxes
textbox_name_anim_speed=        0;
textbox_name_anim_subimgs=      0;

//Name box text
textbox_name_text_x=            textbox_name_x+8;
textbox_name_text_y=            textbox_name_y+4;
textbox_name_text_color=        $000000; //also black
textbox_name_text_alpha=        1;

//In-box questions
textbox_question_text_x_offset=       24; //how much the question text is offset from the left end of the textbox
textbox_question_text_y_offset=       6; //how much the question text is offset from the normal newline y
textbox_question_text_x_separation=   32; //how much space is between the two questions
textbox_question_text_x[0]=           textbox_question_text_x_offset;
textbox_question_text_y=              textbox_text_y+(textbox_font_height*(textbox_maxlines-1)); //so that the question text displays on the last line of the textbox
textbox_question_text_color=          $1f1f1f; //dark gray
textbox_question_text_alpha=          1;

//In-box question cursor
textbox_question_cursor_x_offset=       4; //how far away the cursor is from the text
textbox_question_cursor_y_offset=       3; //how far down the cursor is compared to the actual position of the text
textbox_question_cursor_y=              0;
textbox_question_cursor_sprite=         spr_textbox_questionbox_cursor;
textbox_question_cursor_sprite_xsize=   8;
textbox_question_cursor_color=          $000000; //black
textbox_question_cursor_alpha=          1;
textbox_question_cursor_anim=           1; //for animated cursors
textbox_question_cursor_anim_speed=     0.067;
textbox_question_cursor_anim_subimgs=   2;

//Question box
textbox_vnquestion_sprite=              spr_textbox_questionbox;
textbox_vnquestion_x=                   view_wport/2;
textbox_vnquestion_y=                   64;
textbox_vnquestion_y_offset=            0; //this is relative to how many answers there are
textbox_vnquestion_height=              12; //the height of each individual part of the question box
textbox_vnquestion_alpha=               1;

//Question box text
textbox_vnquestion_text_x=              textbox_vnquestion_x;
textbox_vnquestion_text_y=              textbox_vnquestion_y+5;
textbox_vnquestion_text_color=          $000000; //black
textbox_vnquestion_text_alpha=          1;

//Question box cursor
textbox_vnquestion_cursor_x=            textbox_vnquestion_x;
textbox_vnquestion_cursor_y_offset=     1;
for (i=0; i&lt;textbox_maxoptions; i++) { //set y offsets for multiple question positions
  textbox_vnquestion_cursor_y[i]=       textbox_vnquestion_text_y+textbox_vnquestion_cursor_y_offset+(i*12);
}
textbox_vnquestion_cursor_y_move=       1; //1 moves cursor gradually
textbox_vnquestion_cursor_current_y=    textbox_vnquestion_cursor_y[0];
textbox_vnquestion_cursor_sprite=       spr_textbox_questionbox_cursor;
textbox_vnquestion_cursor_alpha=        .5;
textbox_vnquestion_cursor_anim=         0; //for animated cursors
textbox_vnquestion_cursor_anim_speed=   0;
textbox_vnquestion_cursor_anim_subimgs= 0;

//Cut-ins
textbox_cutin_enabled=                  1; //0 if you're not using cutins
textbox_cutin_y=                        view_hport;
textbox_cutin_fade=                     1; //whether cut-ins fade in and out upon creation and destruction
textbox_cutin_fade_perstep=             .1; //how much cutins fade in and out per step

//Textbox SFX
textbox_sound_open=                     snd_textbox_open;
textbox_sound_move=                     snd_textbox_move;
textbox_sound_select=                   snd_textbox_select;
textbox_sound_close=                    snd_textbox_close;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize key bindings
//because not initializing variables is the devil's work

switch (os_type) {
  case os_windows: { //easy input changes when porting and default key bindings
    key_left=     vk_left;
    key_right=    vk_right;
    key_up=       vk_up;
    key_down=     vk_down;
    key_advance=  vk_space;
  } break;
}

//these are not OS-specific
keypress_left=    0;
keypress_right=   0;
keypress_up=      0;
keypress_down=    0;
keypress_advance= 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize core variables
//You shouldn't edit these

current_text=-1; //set to negative one so we can check if the alarm "creation" has been called or not

textbox_surface=surface_create(view_wport,view_wport);

start_pointer=0; //this is the pointer for the text loader to know where to start; it's for after you've merged all the text files into one
file_name="text_engine_test_final"; //in case of failure to load anything else

var i, file, temp_fname, text_queue, temp_text, loop_end;
test_level=32; //db

//fyi "db" = "debug"

//Commands
CMD_TEXTSPEED=            "S"; //db
CMD_TEXTVOICE=            "V"; //db
CMD_TEXTPAUSE=            "P"; //db
CMD_TEXTVARIABLE=         "X"; //db
CMD_TEXTVARIABLESET=      "XS"; //db
CMD_TEXTEFFECT=           "F"; //db
CMD_TEXTCOLOR=            "C"; //db
CMD_TEXTNAME=             "N"; //db
CMD_TEXTQUESTION=         "Q"; //db
CMD_TEXTQUESTIONTEXT=     "QT"; //db
CMD_TEXTQUESTIONPOINTER=  "QP"; //db
CMD_CUTINCLEAR=           "IC"; //db
CMD_CUTINNEW=             "IN"; //db
CMD_CUTINOLD=             "IO"; //db
CMD_CUTINMOVE=            "IM"; //db
CMD_CUTINANIMATE=         "IA"; //db
CMD_CUTINANIMATESTOP=     "IS"; //db
CMD_CUTINSWAP=            "IW"; //db
CMD_END=                  "E"; //db
//Arguments
CMD_TEXTSPEED_NORMAL=         "N"; //db
CMD_TEXTSPEED_SLOW=           "S"; //db
CMD_TEXTSPEED_SLOWER=         "R"; //db
CMD_TEXTEFFECT_SFX=           "0"; //db
CMD_TEXTEFFECT_SFX_SHOCK=     "0"; //db
CMD_TEXTVOICE_NULL=           "0"; //db
CMD_TEXTVOICE_LOW=            "L"; //db
CMD_TEXTVOICE_MED=            "M"; //db
CMD_TEXTVOICE_HIGH=           "H"; //db
CMD_TEXTVOICE_THOUGHT=        "T"; //db
CMD_TEXTCOLOR_CLEAR=          "C"; //db
CMD_TEXTCOLOR_BLACK=          0; //db
CMD_TEXTCOLOR_RED=            1; //db
CMD_TEXTCOLOR_GREEN=          2; //db
CMD_TEXTCOLOR_BLUE=           3; //db
CMD_TEXTCOLOR_GRAY=           4; //db
CMD_TEXTNAME_NULL=            "0"; //db
CMD_TEXTQUESTION_YN=          "Y"; //db
CMD_CUTINCLEAR_ALL=           "A"; //db
CMD_CUTIN_UNFLIPPED=          1; //db
CMD_CUTIN_FLIPPED=            -1; //db
//Cutin refs
CUTIN_TEST_NORMAL=        0; //db
CUTIN_TEST_ANGRY=         1; //db

//initialize random variables
textbox_closing=        0; //if this is set to one, the textbox begins closing
textbox_skip_possible=  0; //if skipping to end of text is possible
textbox_skip=           0; //set to 1 if text to be skipped

textbox_arrow_draw=         0;
textbox_arrow_anim_index=   0;

textbox_name_enabled=       0; //disables the name box by default
textbox_name_text=          "";
textbox_name_anim_index=    0;

textbox_text_paused=  0; //if this is set to 1, the textbox will wait until the variable is reset

textbox_question_enabled=             0;
textbox_question_text_x[1]=           0; //this is set when the command is called
textbox_question_text[0]=             "Yes";
textbox_question_text[1]=             "No";
for (i=2; i&lt;textbox_maxoptions; i++) { //the maximum amount of question options is 6
  textbox_question_text[i]="";
}
textbox_question_text_width=string_width(textbox_question_text[0]);

for (i=0; i&lt;2; i++) {
  textbox_question_cursor_x[i]=0;
}
textbox_question_cursor_anim_index=     0;

textbox_vnquestion_enabled=             0; //for visual-novel-styled question boxes
textbox_vnquestion_cursor_anim_index=   0;

textbox_cursor_option=                  0; //which option is highlighted
for (i=0; i&lt;textbox_maxoptions; i++) {
  textbox_cursor_option_pointer[i]=     0; //to set pointer from questions
}

//cut-in data initialization
for (i=0; i&lt;textbox_maxcutins; i+=1) {
  textbox_cutin_draw[i]=      0; //whether this cut-in is being drawn or not
  textbox_cutin_x[i]=         0;
  textbox_cutin_sprite[i,0]=  -1;
  textbox_cutin_flipped[i]=   CMD_CUTIN_UNFLIPPED;
  textbox_cutin_parts[i]=     1; //how many parts the sprite is composed of (for RAM-saving animation of eyes, mouth, etc.)
  if (textbox_cutin_fade) {
    textbox_cutin_alpha[i]=   0; //if the cutins fade in and out, we need to start at zero
  } else {
    textbox_cutin_alpha[i]=   1;
  }
}

//------Init extra variables
current_text=   0; //the current textbox that is being drawn
current_chr=    0; //the current character for the "typewriting" effect
current_line=   0; //the line of text that is currently being drawn
current_cutins= 0; //the current amount of cut-ins used

for (i=0; i&lt;textbox_maxlines; i++) {
  line_text[i]=   ""; //what text is being drawn to the specified line
  line_chr[i]=    0; //how many characters are in the specified line of text
}

current_colors=     0; //the current amount of colors used
waiting_time=       1;  //the amount of steps passed; used for altering text speed
text_draw_speed=    1; //1 = Normal, 3 = Slow, 8 = Slower
text_voice=         0; //0 = Null, 1 = Low, 2 = Med, 3 = High, 4 = Thought
pause_time_waited=  0; //the amount of steps passed while waiting for a pause to finish
pause_time_to=      0; //the amount of steps needed to wait for a pause to finish
drawing_color=      0; //if the text being drawn is a color other than the default

for (i=0; i&lt;textbox_maxcolors; i++) {
  current_color_chr_start[i]=   0; //what character the colored text starts at
  current_color_chr_end[i]=     0; //what character the colored text ends at
  color_id[i]=                  0; //so the text color changer knows which part of the text is which color
  color_x[i]=                   0; //positioning of the colored text
  color_y[i]=                   0; //same as above
  color_text[i]=                ""; //what the colored text contains
  color_text_line[i]=           0; //which line of text the colored text is on
}
question_amount=                0; //the total number of questions
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Clean data

ds_queue_destroy(cmd_data_queue);
ds_queue_destroy(cmd_pos_queue);
surface_free(textbox_surface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Poll inputs
//in Begin Step so it's done first

switch(os_type) { //checks for text commands
  case os_windows: { //parses commands
    keypress_left=    keyboard_check_pressed(key_left); //colored text
    keypress_right=   keyboard_check_pressed(key_right); //question boxes
    keypress_up=      keyboard_check_pressed(key_up); //text speed
    keypress_down=    keyboard_check_pressed(key_down); //text voice
    keypress_advance= keyboard_check_pressed(key_advance); //text to end
  } break; //close textbox
} //and that's all the code you need for the textbox!
//  isn't that simple?






















//I need to stop messing around with comments
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input actions
var i;

if (keypress_advance) {
  if (current_chr&gt;=string_length(edited_text[current_text])) {
    if (current_text&lt;total_boxes) {
      if (textbox_arrow_draw) { //putting this here stops a bug where pushing space before the arrow is drawn closes the textbox altogether
        output_text=""; //resets for prevention of bugs
        textbox_skip=0; //reset textbox skipping
        current_chr=0;
        current_colors=0;
        for (i=0; i&lt;textbox_maxcolors; i++) {
          current_color_chr_start[i]=0;
          current_color_chr_end[i]=0;
          color_id[i]=0;
          color_text[i]="";
        }
        textbox_arrow_draw=0;
        textbox_arrow_anim_index=0;
        current_text+=1;
        current_line=0;
        for (i=0; i&lt;textbox_maxlines; i++) {
          line_text[i]="";
          line_chr[i]=0;
        }
        textbox_cmd_load(input_text[current_text]);
        next_cmd_pos=ds_queue_head(cmd_pos_queue);
      }
    } else {
      if (textbox_question_enabled || textbox_vnquestion_enabled) {
        audio_play_sound(textbox_sound_select,1,0);
        textbox_question_enabled=0;
        textbox_vnquestion_enabled=0;
        output_text=""; //resets for prevention of bugs
        textbox_skip=0; //reset textbox skipping
        current_chr=0;
        current_colors=0;
        for (i=0; i&lt;textbox_maxcolors; i++) {
          current_color_chr_start[i]=0;
          current_color_chr_end[i]=0;
          color_id[i]=0;
          color_text[i]="";
        }
        textbox_arrow_draw=0;
        textbox_arrow_anim_index=0;
        current_text=0;
        current_line=0;
        for (i=0; i&lt;textbox_maxlines; i++) {
          line_text[i]="";
          line_chr[i]=0;
        }
        textbox_question_pointer(textbox_cursor_option_pointer[textbox_cursor_option]);
        textbox_cursor_option=0; //reset this to fix any bugs with using less questions after more
      } else {
        if (!textbox_closing) {
          audio_play_sound(textbox_sound_close,1,0);
          textbox_closing=1;
        }
      }
    }
  } else { //skip to end of textbox
    if (textbox_skip_possible &amp;&amp; !textbox_skip) {
      textbox_skip=1;
      while (current_chr&lt;string_length(edited_text[current_text])) {
        textbox_typewriter();
      }
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Various things


//Textbox Fade-in
if (textbox_overall_alpha&lt;textbox_overall_alpha_max)
{
  textbox_overall_alpha+=textbox_fade_perstep;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cut-in animation / Close textbox
var i, j, fade_waiting;

fade_waiting=0; //so that the typing and closing system will wait while the cut-ins are fading

if (current_cutins&gt;0) {
  for (i=0; i&lt;current_cutins; i++) { //repeats for every cut-in
    if (textbox_closing) {
      if (textbox_cutin_alpha[i]&gt;0) {
        textbox_cutin_alpha[i]-=textbox_cutin_fade_perstep;
        fade_waiting++;
      }
    } else {
      if (textbox_cutin_fade) {
        if (textbox_cutin_draw[i]) {
          if (textbox_cutin_alpha[i]&lt;1) {
            textbox_cutin_alpha[i]+=textbox_cutin_fade_perstep;
            fade_waiting++;
          }
        } else {
          if (textbox_cutin_alpha[i]&gt;0) {
            textbox_cutin_alpha[i]-=textbox_cutin_fade_perstep;
            if (textbox_cutin_alpha[i]==0) {
              textbox_cutin_draw[i]=1; //reset for fix after swapping
              current_cutins--;
            } else {
              fade_waiting++;
            }
          }
        } 
      }
      if (textbox_cutin_draw[i]) {
        for (j=0; j&lt;textbox_cutin_parts[i]; j++) { //draws each part individually
          if (textbox_cutin_anim[i,j]) { //checks if this part is to be animated, and if this cutin should be drawn
            if (textbox_cutin_anim_index[i,j]&lt;(textbox_cutin_anim_subimgs[i,j]-textbox_cutin_anim_speed[i,j])) { //minus anim speed to check for the true last frame of animation
             textbox_cutin_anim_index[i,j]+=textbox_cutin_anim_speed[i,j];
            } else {
              if (textbox_cutin_anim_time_waited[i,j]&lt;textbox_cutin_anim_wait[i,j]) { //checks to see if we need to wait a while before performing the animation again (i.e. blinking eyes)
                if (textbox_cutin_anim_index[i,j]&lt;textbox_cutin_anim_subimgs[i,j]) {
                  textbox_cutin_anim_index[i,j]+=textbox_cutin_anim_speed[i,j]; //to stop on first frame of animation
                }
                textbox_cutin_anim_time_waited[i,j]++;
              } else {
                if (textbox_cutin_anim_loop[i,j]) { //reset the image index if the animation is looped
                  textbox_cutin_anim_index[i,j]=0;
                  textbox_cutin_anim_time_waited[i,j]=0;
                } else { //stops the animation if it's not supposed to loop
                  textbox_cutin_anim[i,j]=0;
                  if (textbox_text_paused) { //unpauses the text after the animation
                    textbox_text_paused=0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

if (textbox_closing &amp;&amp; fade_waiting==0) { //quit the textbox if everything is already faded out
  instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Typewriter effect

if (!textbox_text_paused &amp;&amp; !textbox_closing &amp;&amp; fade_waiting==0 &amp;&amp; textbox_overall_alpha&gt;=textbox_overall_alpha_max) { //if drawing the text is paused, we obviously don't want it to keep going
  textbox_typewriter();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Misc sprite animation

if (textbox_arrow_draw &amp;&amp; textbox_arrow_anim) { //animates the textbox arrow if it can animate
  if (textbox_arrow_anim_index&lt;textbox_arrow_anim_subimgs) {
    textbox_arrow_anim_index+=textbox_arrow_anim_speed;
  } else {
    textbox_arrow_anim_index=0;
  }
}

if (textbox_question_enabled &amp;&amp; textbox_question_cursor_anim) { //animates the question cursor if it can animate 
    if (textbox_question_cursor_anim_index&lt;textbox_question_cursor_anim_subimgs) {
      textbox_question_cursor_anim_index+=textbox_question_cursor_anim_speed;
    } else {
      textbox_question_cursor_anim_index=0;
    }
  }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Question cursor movement

//In-box question
if (textbox_question_enabled) {
  if (keypress_left ^^ keypress_right) {
    audio_play_sound(textbox_sound_move,1,0);
    textbox_cursor_option = !textbox_cursor_option; //since in this case, it can only be 1 or 0, just reverse the values
  }
}

//Question box
if (textbox_vnquestion_enabled) {
  if (keypress_up &amp;&amp; !keypress_down) {
    audio_play_sound(textbox_sound_move,1,0);
    if (textbox_cursor_option &gt; 0) {
      textbox_cursor_option-=1;
    } else {
      textbox_cursor_option=question_amount-1;
    }
  }
  if (keypress_down &amp;&amp; !keypress_up) {
    audio_play_sound(textbox_sound_move,1,0);
    if (textbox_cursor_option &lt; question_amount-1) {
      textbox_cursor_option+=1;
    } else {
      textbox_cursor_option=0;
    }
  }
  if (textbox_vnquestion_cursor_y_move==1) { //for moving the textbox gradually
    if (textbox_vnquestion_cursor_current_y &lt; textbox_vnquestion_cursor_y[textbox_cursor_option]) {
      if (textbox_vnquestion_cursor_current_y &lt; textbox_vnquestion_cursor_y[textbox_cursor_option]-4) { //we want the cursor to move at different speeds depending on how much it has to travel
        textbox_vnquestion_cursor_current_y+=4;
      } else if (textbox_vnquestion_cursor_current_y &lt; textbox_vnquestion_cursor_y[textbox_cursor_option]) {
        textbox_vnquestion_cursor_current_y+=1;
      }
    } else if (textbox_vnquestion_cursor_current_y &gt; textbox_vnquestion_cursor_y[textbox_cursor_option]) {
      if (textbox_vnquestion_cursor_current_y &gt; textbox_vnquestion_cursor_y[textbox_cursor_option]+4) {
        textbox_vnquestion_cursor_current_y-=4;
      } else if (textbox_vnquestion_cursor_current_y &gt; textbox_vnquestion_cursor_y[textbox_cursor_option]) {
        textbox_vnquestion_cursor_current_y-=1;
      }
    }
  } else {
    textbox_vnquestion_cursor_current_y = textbox_vnquestion_cursor_y[textbox_cursor_option];
  }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drawing to surface
//on a separate surface so the entire textbox alpha can be changed

if (!surface_exists(textbox_surface)) { //for solving annoying glitches
  textbox_surface=surface_create(room_width,room_width);
}
surface_set_target(textbox_surface);
  draw_clear_alpha($ffffff,0);
  draw_sprite_ext(textbox_sprite,0,textbox_x,textbox_y,1,1,0,$ffffff,textbox_alpha);
  draw_set_font(global.fnt_textbox);
  if (textbox_name_enabled) {
    draw_set_color(textbox_name_text_color)
    draw_sprite(textbox_name_sprite,textbox_name_anim_index,textbox_name_x,textbox_name_y);
    draw_text(textbox_name_text_x,textbox_name_text_y,textbox_name_text);
  }
  draw_set_color(textbox_text_color);
  draw_text(textbox_text_x,textbox_text_y,output_text);
  for (i=0; i&lt;current_colors; i+=1) {
    draw_set_color(color_id[i]);
    draw_text(color_x[i],color_y[i],color_text[i]);
  }
  if (textbox_arrow_draw==1) {
    draw_sprite_ext(textbox_arrow_sprite,textbox_arrow_anim_index,textbox_arrow_x,textbox_arrow_y,1,1,0,textbox_arrow_color,textbox_arrow_alpha);
  }
  
  //in-box questions
  if (textbox_question_enabled) {
    draw_set_color(textbox_question_text_color);
    for (i=0; i&lt;2; i+=1) {
      draw_text(textbox_question_text_x[i],textbox_question_text_y,textbox_question_text[i]);
    }
    draw_sprite_ext(spr_textbox_cursor,textbox_question_cursor_anim_index,textbox_question_cursor_x[textbox_cursor_option],textbox_question_cursor_y,1,1,0,textbox_question_cursor_color,textbox_question_cursor_alpha);
  }

  //question boxes
  if (textbox_vnquestion_enabled) {
    draw_set_color(textbox_vnquestion_text_color);
    draw_sprite_ext(textbox_vnquestion_sprite,0,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset,1,1,0,$ffffff,textbox_vnquestion_alpha);
    for (i=0; i&lt;question_amount-1; i+=1) {
      draw_sprite_ext(textbox_vnquestion_sprite,1,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset+((i+1)*textbox_vnquestion_height),1,1,0,$ffffff,textbox_vnquestion_alpha);
    }
    draw_sprite_ext(textbox_vnquestion_sprite,2,textbox_vnquestion_x,textbox_vnquestion_y+textbox_vnquestion_y_offset+(question_amount*textbox_vnquestion_height),1,1,0,$ffffff,textbox_vnquestion_alpha);
    draw_set_halign(fa_middle);
      for (i=0; i&lt;question_amount; i+=1) {
        draw_text(textbox_vnquestion_text_x,textbox_vnquestion_text_y+textbox_vnquestion_y_offset+(i*textbox_vnquestion_height),textbox_question_text[i]);
      }
    draw_set_halign(fa_left);
  }
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Load vital textbox vars

textbox_loadbox(file_name, start_pointer);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw textbox surface and cutins
var i, j;

if (current_text&gt;-1) { //checks if the alarm "create event" has been completed
  //drawing cut-ins first so that the textbox can cover them
  if (current_cutins&gt;0) {
    for (i=0; i&lt;current_cutins; i+=1) { //repeats for every cut-in
      for (j=0; j&lt;textbox_cutin_parts[i]; j+=1) { //draws each part individually
        draw_sprite_ext(textbox_cutin_sprite[i,j],textbox_cutin_anim_index[i,j],textbox_cutin_x[i]+(textbox_cutin_part_x_offset[i,j]*textbox_cutin_flipped[i]),textbox_cutin_y+textbox_cutin_part_y_offset[i,j],textbox_cutin_flipped[i],1,0,$ffffff,textbox_cutin_alpha[i]);
      }
    }
  }
  if (!textbox_closing) {
    draw_surface_ext(textbox_surface,0,0,1,1,0,$ffffff,textbox_overall_alpha);
    if (textbox_vnquestion_enabled) {
      draw_sprite_ext(textbox_vnquestion_cursor_sprite,textbox_vnquestion_cursor_anim_index,textbox_vnquestion_cursor_x,textbox_vnquestion_cursor_current_y+textbox_vnquestion_y_offset,1,1,0,$ffffff,textbox_vnquestion_cursor_alpha);
    }
  }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
